# 2.8 리팩터링과 서능

## 직관적인 설계 vs. 성능

리팩터링하면 소프트웨어가 느려질 수도 있는 건 사실이다. 하지만 그와 동시에 성닝을 튜닝하기는 쉬워진다.

하드 리얼타임 시스템을 제외한 소프트웨어를 빠르게 만드는 비결은, 먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하는 것이다.

## 빠른 소프트웨어를 작성하는 방법 3가지

### 1. 시간 예산 분배 방식 time budgeting

가장 엄격한 방법으로, 하드 리얼타임 시스템에서 많이 사용한다.

- 여러 컴포넌트로 나눠서 컴포넌트마다 자원(시간과 공간) 예산을 할당한다.
- 컴포넌트는 할당된 자원 예산을 초과할 수 없다.
- 단, 주어진 자원을 서로 주고받는 메커니즘을 제공할 수 있다.
- 엄격한 시간 엄수를 강조한다.
- 데이터가 늦게 도착하면 안 되는 시스템에서는 이러한 점이 굉장히 중요하다.
  - ex: 심장 박동 조율기 <-> 사내 정보 시스템

### 2. 끊임 없이 관심을 기울기

- 직관적이어서 흔히 사용하는 방식이지만 실제 효과는 변변치 않다.
- 성능 개선을 위해 코드를 수정하다 보면 프로그램은 다루기 어려운 형태로 변하기 쉬워 결국 개발이 더뎌진다.
- 결과적으로 더 빨라지면 충분한 보상을 얻겠지만 실제로 그런 경우는 별로 없다.
- 성능 개선을 위한 최적화가 프로그램 전반에 퍼지게 되는데, 각각의 개선은 프로그램의 특정 동작에만 관련될 뿐, 정작 컴파일러와 런타임과 하드웨어의 동작을 제대로 이해하지 못한 채 작성할 때도 많다.

> 아무것도 안 만드는 데도 시간이 걸린다 \_론 젠프리
>
> 테스트 속도마저 떨어뜨려서 점점 거슬리게 된 프로세스가 있었다. 켄트 벡의 프로파일러를 이용하여 실제 성능을 분석한 결과, 날짜 인스턴스를 생성하는 데 실행 시간의 절반을 쓰고 있는 것을 발견했다. 게다가 그 많은 인스턴스들의 값들이 고작 두어 가지였다.
>
> > 이 날짜 생성 로직에서 최적화할 만한 부분은 1. 입력 받는 것도 전혀 없는데 날짜들을 모두 문자열 변환을 거쳐 만들고 있었다는 점, 2. 날짜 구간을 타나내는 인스턴스(시작 날짜와 종료 날짜) 객체를 생성하고 있었다는 점이다.
>
> 시스템에 대해 잘 알더라도 섣불리 추측하지 말고 성능을 측정해봐야 한다. 그러면 새로운 사실을 배우게 되는데, 십중팔구 내가 잘못 알고 있었음을 깨닫게 된다.

**성능에 대한 흥미로운 사실은, 대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다는 것이다.** 그래서 코드 전체를 고르게 최적화한다면 그중 90%는 효과가 거의 없기 때문에 시간 낭비인 셈이다. 속도를 높이기 위해 투자한 시간(다른 관점에서 보면 코드를 덜 명료하게 바꾸느라 투자한 시간)을 모두 날리는 행위다.

### 3. '90%의 시간은 낭비'

**의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경 쓰지 않고 코드를 다루기 쉽게 만드는 데 집중한다.** 그러다 성능 최적화 단계가 되면 다음의 구체적인 절차를 따라 프로그램을 튜닝한다.

3-1. 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 잡아낸다.

- 성능에 큰 영향을 주는 작은 부분들을 찾을 수 있다.

3-2. 전체를 고르게 최적화 할 때와 마찬가지 방법으로 그 부분들을 개선한다.

- 성능에 큰 영향을 주는 부분만 집중해서 최적화하기 때문에 적은 노력으로 훨씬 큰 효과를 볼 수 있다.
- 신중한 컴파일과 테스트를 거치고 프로파일러를 다시 실행해본다.

3-3. 성능이 개선되지 않았다면 수정 내용을 되돌린다.

- 사용자가 만족하는 성능에 도달할 때까지 최적화 대상을 찾아서 제거하는 일을 계속한다.

> 이렇게 해서 도움되는 최적화에 도움되는 2가지 ?
>
> > **1. 성능 튜닝에 투입할 시간을 벌 수 있다.** 기능 추가가 빨리 끝나서 성능에 집중할 시간을 더 벌 수 있다.
>
> > **2. 성능을 더 세밀하게 분석할 수 있다.** 프로파일러가 지적해주는 코드의 범위가 더 좁아질 것이고, 그래서 튜닝하기 쉬워진다. 코드가 깔끔하면 개선안들이 더 잘 떠오를 것이고, 그중 어떤 튜닝이 효과가 좋을지 파악하기 쉽다.
