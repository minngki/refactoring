## 2.5 리팩터링 시 고려할 문제

무언가를 언제 어디에 적용할지 판단하려면 손익을 제대로 이해해야 한다. 리팩터링에 딸려오는 문제도 엄연히 존재하므로, 이런 문제가 언제 발생하고 어떻게 대처하는지 반드시 알아야 한다.

### 1. 새 기능 개발 속도 저하

리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

#### 리팩터링부터 바로 진행하는 경우 ?

- 새 기능을 구현해넣기 편해지겠다 싶을 때
- 비슷한 패턴의 지저분한 코드를 마주칠 때
  - 물론 여러 차례 마주친 뒤에야 진행할 수도 있다.

#### 리팩터링을 미루는 경우 ?

- 내가 직접 건드릴 일이 거의 없을 때
- 불편한 정도가 그리 심하지 않다고 판단될 때
- 어떻게 개선해야할지 확실히 떠오르지 않을 때

### 2. 코드 소유권

코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다. 클라이언트에 영향을 주지 않고서는 원하는 형태로 변경할 수 없기 때문이다.

리팩터링의 제약은 예컨대, 함수 이름 바꾸기를 적용할 때, 기존 함수도 그대로 유지하되 함수 본문에서 새 함수를 호출하도록 수정하는 방법 뿐이다. 기존 인터페이스를 폐기 대상으로 지정하고 시간이 흐른 뒤에 삭제할 수도 있지만, 때로는 영원히 남겨둬야 할 수도 있다.

### 3. 브랜치

버전 관리 시스템을 사용하여 팀원마다 코드베이스의 브랜치를 하나씩 맡아서 작업하다가, 결과물이 어느 정도 쌓이면 마스터 브랜치에 통합해서 다른 팀원과 공유하는 것이 일반적이다.

하지만 이렇게 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워진다. 이 고통을 줄이고자 많은 이들이 마스터를 개인 브랜치로 수시로 리베이스하거나 머지한다. 그러나 여러 기능 브랜치에서 동시에 개발이 진행된다면 이런 식으로 해결할 수 없다.  
머지와 통합을 구분해야 한다.

- 머지: 단방향 (마스터는 그대로임)
- 통합: 양방향 (마스터에서 pull하여 작업 결과를 마스터에 push)

기능별 브랜치를 자주 통합할 수 있다면 문제발생 가능성은 크게 줄일 수 있다. 지속적 통합(CI: Continuous Integration)을 적용해서 통합 주기만큼은 최대한 짧게 잡아야한다.

### 4. 테스팅

리팩터링의 핵심은 기존 동작이 깨지지 않아야 한다는 것인데, 실수를 저지른다면 재빨리 해결해야 한다. 리팩터링은 단계별 변경을 하므로 폭이 좁기 때문에 오류 범위도 넓지 않다. 이를 수시로 빠르게 테스트해보기 위해서는 자가 테스트 코드를 만들어야 한다.

자가 테스트 코드는 통합 과정에서 발생하는 의미 충돌을 잡는 메커니즘으로 활용할 수 있어서 자연스럽게 CI와도 밀접하게 연관된다. CI에 통합된 테스트는 XP의 권장사항이자 지속적 배포(CD: Continuous Delivery)의 핵심이기도 하다.

### 5. 레거시 코드

물려받은 레거시 코드는 대체로 복잡하고 테스트도 제대로 갖춰지지 않은 것이 많다. 무엇보다도 다른 사람이 작성한 것이다..!
레거시 시스템을 파악할 때 리팩터링이 굉장히 도움된다. 제 기능과 맞지 않은 함수 이름을 바로 잡고 어설픈 프로그램 구문을 매끄럽게 다듬을 수 있다.  
**그러나 대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하기는 어렵다.**

1. 따라서 당연히 테스트 보강을 해야 한다.

   > - 📕 _레거시 코드 활용 전략 읽어보기_  
   >    '프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다.'  
   >    ➡️ 틈새를 만들 때 리팩터링이 활용이 되는데, 테스트 없이 진행하기 때문에 상당히 위험하지만 문제를 해결하기 위해서 감내해야할 위험이다. 이럴 때 자동 리팩터링 도구가 있다면 큰 도움이 된다.

2. **코드의 한 부분을 훑고 넘어갈 때 마다 예전보다 조금이라도 개선하려고 노력한다.** 테스트를 갖추고 있더라도 복잡하게 얽혀있기 때문에 **서로 관련된 부분끼리 나눠서 하나씩 공략하는 것이다.**

3. **레거시 시스템의 규모가 크다면 자주 보는 부분을 더 많이 리팩터링한다.** 코드를 훑게 되는 횟수가 많다는 말은 그 부분을 이해하기 쉽게 개선했을 때 얻는 효과도 그만큼 크다는 뜻이니 당연히 해야 한다.

### 6. 데이터베이스

진화형 DB 설계, DB 리팩터링 기법은 현재 널리 적용되고 있다. 이 기법의 핵심은 **커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고, 접근 코드와 DB 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합**하는 데 있다.

이 기법도 전체 변경 과정을 작고 독립된 단계들로 쪼개야 한다. 그래야 마이그레이션 후에도 정상 작동할 수 있다. 단계를 잘게 나누면 코드도 쉽게 작성할 수 있다. 여러 단계를 순차적으로 연결해서 DB 구조와 그 안에 담긴 데이터를 큰 폭으로 변경할 수도 있다.

DB 리팩터링은 **프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다**는 점에서 다른 리팩터링과 다르다. 문제가 생겼을 때 변경을 되돌리기 쉽기 때문이다. 예를 들면, 필드 이름을 바꿀 때 첫번째 커밋에서는 새로운 DB 필드를 추가만 하고 사용하지는 않는다. 그런 다음 기존 필드와 새 필드를 동시에 업데이트하도록 설정한다. 그 다음에는 DB를 읽는 클라이언트들을 새 필드를 사용하는 버전으로 조금씩 교체한다. 이 과정에서 발생하는 버그도 해결하면서 클라이언트 교체 작업을 모두 끝냈다면, 더는 필요가 없어진 예전 필드를 삭제한다. 이렇게 DB를 변경하는 방식은 **병렬수정(팽창-수축)**의 일반적인 예다.
