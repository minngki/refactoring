## 2.5 리팩터링 시 고려할 문제

무언가를 언제 어디에 적용할지 판단하려면 손익을 제대로 이해해야 한다. 리팩터링에 딸려오는 문제도 엄연히 존재하므로, 이런 문제가 언제 발생하고 어떻게 대처하는지 반드시 알아야 한다.

### 1. 새 기능 개발 속도 저하

리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

#### 리팩터링부터 바로 진행하는 경우 ?

- 새 기능을 구현해넣기 편해지겠다 싶을 때
- 비슷한 패턴의 지저분한 코드를 마주칠 때
  - 물론 여러 차례 마주친 뒤에야 진행할 수도 있다.

#### 리팩터링을 미루는 경우 ?

- 내가 직접 건드릴 일이 거의 없을 때
- 불편한 정도가 그리 심하지 않다고 판단될 때
- 어떻게 개선해야할지 확실히 떠오르지 않을 때

### 2. 코드 소유권

코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다. 클라이언트에 영향을 주지 않고서는 원하는 형태로 변경할 수 없기 때문이다.  
리팩터링의 제약은 예컨대, 함수 이름 바꾸기를 적용할 때, 기존 함수도 그대로 유지하되 함수 본문에서 새 함수를 호출하도록 수정하는 방법 뿐이다. 기존 인터페이스를 폐기 대상으로 지정하고 시간이 흐른 뒤에 삭제할 수도 있지만, 때로는 영원히 남겨둬야 할 수도 있다.

### 3. 브랜치

버전 관리 시스템을 사용하여 팀원마다 코드베이스의 브랜치를 하나씩 맡아서 작업하다가, 결과물이 어느 정도 쌓이면 마스터 브랜치에 통합해서 다른 팀원과 공유하는 것이 일반적이다.  
하지만 이렇게 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워진다. 이 고통을 줄이고자 많은 이들이 마스터를 개인 브랜치로 수시로 리베이스하거나 머지한다. 그러나 여러 기능 브랜치에서 동시에 개발이 진행된다면 이런 식으로 해결할 수 없다.  
머지와 통합을 구분해야 한다.

- 머지: 단방향 (마스터는 그대로임)
- 통합: 양방향 (마스터에서 pull하여 작업 결과를 마스터에 push)

기능별 브랜치를 자주 통합할 수 있다면 문제발생 가능성은 크게 줄일 수 있다. 지속적 통합(CI: Continuous Integration)을 적용해서 통합 주기만큼은 최대한 짧게 잡아야한다.

### 4. 테스팅

리팩터링의 핵심은 기존 동작이 깨지지 않아야 한다는 것인데, 실수를 저지른다면 재빨리 해결해야 한다. 리팩터링은 단계별 변경을 하므로 폭이 좁기 때문에 오류 범위도 넓지 않다. 이를 수시로 빠르게 테스트해보기 위해서는 자가 테스트 코드를 만들어야 한다.  
자가 테스트 코드는 통합 과정에서 발생하는 의미 충돌을 잡는 메커니즘으로 활용할 수 있어서 자연스럽게 CI와도 밀접하게 연관된다. CI에 통합된 테스트는 XP의 권장사항이자 지속적 배포(CD: Continuous Delivery)의 핵심이기도 하다.

### 5. 레거시 코드

물려받은 레거시 코드는 대체로 복잡하고 테스트도 제대로 갖춰지지 않은 것이 많다. 무엇보다도 다른 사람이 작성한 것이다..!
레거시 시스템을 파악할 때 리팩터링이 굉장히 도움된다. 제 기능과 맞지 않은 함수 이름을 바로 잡고 어설픈 프로그램 구문을 매끄럽게

### 6. 데이터베이스
