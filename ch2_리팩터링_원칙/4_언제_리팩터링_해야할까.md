## 2.4 언제 리팩터링해야 할까?

거의 한 시간 간격으로 리팩터링 ?

### 3의 법칙

1. 처음에는 그냥 한다.
2. 비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다.
3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

### 1. 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

리팩터링하기 <ins>가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전</ins>이다. 이 시점에 현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다.

\*️⃣ **코드를 복제하게 되면 어떤 일이 발생할까 ?**

요구사항을 거의 만족하지만 리터럴 값 몇 개가 방해되는 함수가 있을 수 있다. 함수를 복제해서 해당 값만 수정해도 되지만, 그러면 중복 코드가 생긴다. 이렇게 **복사해서 붙여넣는 방식으로 처리하면** 나중에 새 기능을 약간 변형한 버전을 만들어야 할 때 번거로울 수 있다.
그래서 이럴 때는 **함수 매개변수화하기를 적용한다. 그러고 나면 그 함수에 필요한 매개변수를 지정해서 호출**하기만 하면 된다.

버그를 잡을 때도 마찬가지다. 오류를 일으키는 코드가 세 곳에 복제되어 있다면, 우선 한 곳으로 합치는 편이 작업하기에 훨씬 편하다.

### 2. 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

코드를 수정하라면 먼저 그 코드가 하는 일을 파악해야 하는데, 그 코드를 작성한 사람은 본인 또는 타인일 수 있다. 코드를 파악할 때 마다 그 **코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다.**

- 조건부 로직의 구조가 이상하지 않은지 살펴보기도 하고,
- 함수 이름을 잘못 정해서 실제로 하는 일을 파악하는 데 시간이 오래 걸리지는 않는지 살펴본다.
- 어떤 역할을 하는지 이해된 변수는 적절한 이름으로 바꿔주고,
- 긴 함수를 잘게 나누기도 한다.

➡️ 이렇게 코드가 깔끔하게 정리되면 설계가 눈에 들어오며, 도달하지 못했을 더 깊은 수준까지 이해하게 된다.

### 3. 쓰레기 줍기 리팩터링

일을 비효율적으로 처리하는 코드를 발견할 때가 있다.

- 로직이 쓸데없이 복잡하거나,
- 매개변수화한 함수 하나면 될 일을 거의 똑같은 함수 여러 개로 작성해놨을 수 있다.

원래 하려던 작업과 관련 없는 일에 너무 많은 시간을 빼앗길 수 없으니, **간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리**한다.

**수정할 양이 방대할 수 있고 더 급한 일이 있을 수 있지만, 조금이나마 개선해두는 것이 좋다.** 코드를 훑어볼 때 마다 조금씩 개선하다 보면 결국 문제가 해결된다.

### 4. 계획된 리팩터링과 수시로 하는 리팩터링

앞의 1~3번은 기회가 될 때만 진행한다. **프로그래밍 과정에 자연스럽게 녹여야 한다. 개발에 들어가기 전에 리팩터링 일정을 따로 잡아두지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 한다.** 리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다.

> 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드는 역시 수많은 리팩터링을 거쳐야한다.

어제는 적합했던 기준이 오늘 하는 다른 작업에는 맞지 않을 수 있다. (휴~ 나만 그런 줄~) 이렇게 상황이 변해 기준을 변경해야할 때 코드가 이미 깔끔하다면 리팩터링하기 더 쉽다!

> 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다)  
> 그런 다음 쉽게 수정하자.

소프트웨어 개발이란 '추가'하는 과정으로 많이 여기지만, 기능을 추가하다보면 대개 새로운 코드를 작성하게 된다. 하지만 **뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 '수정'하는 것이 그 기능을 가장 빠르게 추가하는 길**일 수 있음을 안다.

소프트웨어 개발은 끝이 있는 작업이 아니다. 이 때 새로 작성해 넣는 코드보다 기존 코드의 수정량이 큰 경우가 대체로 많다.

계획된 리팩터링이 나쁜 건 아니지만, 최소한으로 줄여야한다. 작업 대부분은 드러나지 않게, 기회가 될 때 마다 해야한다.

\*️⃣ **커밋?**

**리팩터링은 기능 추가와 밀접하게 엮인 경우가 너무나 많기 때문에 굳이 나누는 것은 시간낭비일 수 있다.** 또한 해당 리팩터링을 하게 된 **맥락 정보가 사라져서 왜 그렇게 수정했는지 이해하기 어려워진다.** 리팩터링 커밋을 분리한다고 해서 무조건 좋은 것은 아님을 명심하자.

### 5. 오래 걸리는 리팩터링

리팩터링은 대부분 몇 분 안에 끝난다. 길어야 몇 시간 정도다. 하지만 팀 전체가 달려들어도 몇 주는 걸리는 대규모 리팩터링도 있다.

- 라이브러리를 새 것으로 교체하는 작업일 수도 있고,
- 일부 코드를 다른 팀과 공유하기 위해 컴포넌트로 빼내는 작업일 수도 있다.
- 또는 그동안 쌓여온 골치 아픈 의존성을 정리하는 작업일 수도 있다.

팀 전체가 해당 문제에 매달려있기보다는, **주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많다.**

- 예컨대 라이브러리를 교체할 때는 기존 것과 새 것 모두를 포용하는 추상 인터페이스부터 마련한다. 기존 코드가 이 추상 인터페이스를 호출하도록 만들고 나면 라이브러리를 훨씬 쉽게 교체할 수 있다. (이 전략을 <ins>추상화로 갈아타기</ins>라 한다.)

### 6. 코드 리뷰에 리팩터링 활용하기

- 경험이 더 많은 개발자의 노하우를 더 적은 개발자에게 전수할 수 있다.
- 대규모 소프트웨어 시스템의 다양한 측면을 더 많은 사람이 이해하는 데도 도움된다.
- 깔끔한 코드를 작성하는 데에도 굉장히 중요하다.
- 내 눈에 명확해보여도, 팀원 눈에는 그렇지 않을 수 있다.
- 다른 사람의 아이디어를 얻을 수 있다는 장점도 있다.
- 다른 이의 코드를 리뷰할 때, 머리로만 상상하는 게 아니라 눈으로 직접 확인하면서 직접 리팩토링을 해보면 명확해지고, 한 차원 높은 아이디어가 떠오르기도 한다.
- 결과를 더 구체적으로 도출하는 데에도 도움이 된다. 개선안들을 제시하는 데에 그치지 않고, 그중 상당수를 즉시 구현해볼 수 있기 때문이다.
- 가장 좋은 방법은 **페어 프로그래밍**이다. 작성자와 나란히 앉아서 코드를 훑어가며 리팩터링하는 것이다.

### 7. 관리자에게는 뭐라고 말해야 할까?

기술을 모르는 상당수의 관리자와 고객은 코드베이스의 건강 상태가 생산성에 미치는 영향을 모른다. 이 상황에 있다면 이들에게 '리팩터링한다고 말하지 말라'라고 조언한다.
효과적인 소프트웨어를 최대한 빨리 만드는 것이 프로 개발자의 역할이다.

### 8. 리팩터링하지 말아야 할 때

- 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다. 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 본다.
- 리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다.
  - 직접 리팩터링해보기 전에는 어느 쪽이 쉬운지 확실히 알 수 없을 때도 많아서 쉽지는 않다.
  - 이러한 결정을 잘 하려면 판단력과 경험이 뒷받침돼야 한다.
