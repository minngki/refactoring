# 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

리팩터링은 수년 동안 운영되던 소프트웨어라도 아키텍처를 대폭 변경할 수 있었다. 이 책의 부제처럼 리팩터링으로 기존 코드의 설계를 개선할 수 있다. 하지만 레거시 코드 같은 경우와 튼튼한 테스트 코드가 없다면 변경하기 어려울 때가 많다.

**리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드 베이스를 잘 설계해주는 데 있다.** 코딩 전에 아키텍처를 확장하려할 때의 대표적인 문제는 소프트웨어 요구사항을 사전에 모두 파악해야 한다는 것이다. 하지만 소프트웨어를 실제로 사용해보고 업무에 미치는 영향을 직접 확인하고 나서야 정말로 원하는 바를 알게 되는 경우가 허다하다.

## 향후 변경에 유연하게 대처할 수 있는 **유연성 메커니즘**을 소프트웨어에 심어둔다.

> 💡 유연성 메커니즘이란 ?
>
> > 함수 정의 시 범용적으로 사용 가능할 것 같은 함수를 맞이할 때, 다양한 예상 시나리오에 대응하기 위한 매개변수들을 추가한다. (이러한 매개변수가 유연성 메커니즘이다!)

> 🤔 유연성 메커니즘의 비용 ?  
>  ➡️ 오히려 변화에 대응하는 능력을 떨어뜨릴 때가 대부분이다.
>
> > - 매겨변수를 생각나는 대로 추가하다 보면 당장의 쓰임에 비해 함수가 너무 복잡해진다.
> > - 깜빡 잊은 매개변수가 있다면 앞서 추가해둔 매개변수들 때문에 새로 추가하기 더 어려워진다.
> > - 요구사항이 당초 예상과 다르기 때문에 잘못 구현될 때가 있다.
> > - 설계한 메커니즘 자체에 결함이 있어서 잘못 구현될 때가 있다.

## 간결한 설계, 점진적 설계, You aren't going to need it. (YAGNI)

1. 리팩터링을 활용하면 다르게 접근할 수 있다. 어느 부분에 유연성이 필요하고 어떻게 변화에 가장 잘 대응할 수 있을지 **추측하지 않고, 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다.**
2. 사용자의 요구사항을 더 잘 이해하게 되면 아키텍처도 그에 맞게 리팩터링해서 바꾼다.
3. 그 과정에서 소프트웨어의 복잡도에 지장을 주지 않는 메커니즘은 마음껏 추가하면서, 복잡도를 높일 수 있는 유연성 메커니즘은 반드시 검증을 거친 후 추가한다.
4. 호출하는 측에서 항상 같은 값을 넘기는 매개변수는 매개변수 목록에 넣지 않는다.
5. 매개변수를 추가해야 할 시점이 오면 간단하게 함수 매개변수화하기를 이용하여 해결한다.
6. 예상되는 변경을 미리 반영하는 리팩터링을 미루면 나중에 얼마나 어려워질지를 가늠해보면 판단에 도움될 때가 많다. 이러한 확신이 있을 때만 유연성 메커니즘을 미리 추가한다.

- 아키텍처를 아예 고려하지 말라는 뜻도 아니며 소홀해도 된다는 뜻이 아님.
