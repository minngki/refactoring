## 리팩터링이 필요한 이유: **변경**

- 어떤 방식으로 정하든 반드시 변경 사항이 생긴다.
- 오래 사용할 프로그램이라면 중복 코드는 골칫거리가 된다.
- 복사-붙여넣기 방식은 그리 부담되지 않더라도, 복잡도가 크게 증가한다.
- 다른 사람이 로직을 파악하기 쉬워야 한다.
- 프로그램의 규모가 클수록 수정 과정에서 예상치 못한 문제가 발생할 가능성이 크다.

## 리팩터링의 첫 단계

프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.

> 1. 함수 추출하기

- 코드를 분석해서 얻은(파악한) 정보는 휘발성이 높기 때문에, 잊지 않으려면 재빨리 코드에 반영해야 한다.
- 곧바로 컴파일 후 테스트해서 실수한 게 없는지 확인한다.
  **아무리 간단한 수정이라도 리팩터링 후에는 항상 테스트하는 습관을 들여야한다.**
- 리팩터링은 프로그램 수정을 **작은 단계**로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.
- **하나의 리팩터링이 끝날 때 마다 커밋해야 한다. 그래야 자잘한 문제가 생기더라도 이전의 정상 상태로 다시 돌아갈 수 있다.** 이러한 자잘한 변경들이 어느 정도 의미 있는 단위로 뭉쳐지면 푸시한다.

> 2. 지금보다 더 명확하게 표현할 수 있는 방법이 없는지 검토한다.

- 가장 먼저 변수의 이름을 명확하게 바꿔보자.
- 함수의 반환값은 항상 result로 하자.

> 3. 임시 변수를 제거한다.

- 임시 변수와 같은 로컬 범위에 존재하는 이름이 늘어나면 추출 작업이 복잡해지므로 임시 변수를 질의 함수로 변경하여 변수를 인라인한다. 이 과정에서도 질의 함수로 변경한 후 테스트 - 커밋 과정을 한 후에 진행한다. (이 경우, 성능 관계를 고려해야하지만, 리팩터링된 코드베이스는 성능 개선하기가 훨씬 쉬우니 일단 넘어가자.)
- **임시 변수는 자신이 속한 루틴에서만 의미가 있어서 루틴이 길고 복잡해지기 쉽다.**
- 주석을 남겨두면 오해의 소지가 있으니 웬만하면 삭제하도록 한다.

> 4. 반복문에 의해 누적되는 변수를 쪼갠다.

- 반복문 한 바퀴 돌 때 마다 값을 누적하면 리팩터링하기 까다롭다.
- 먼저 동일한 반복 조건문이어도 쪼갠다.
- 관련된 코드를 한 데 모아둔다. 즉 변수 초기화 문장을 변수 값 누적 코드 바로 앞으로 옮긴다. 임시 변수를 질의 함수로 바꾸기가 수월해진다.
- 함수 추출하기로 해당 부분을 별도 함수로 추출한다.
- 변수 인라인하기로 임시 변수를 제거한다.

> 5. 추출한 함수 내에서 쓰인 이름들도 코딩 스타일에 맞게 변경한다.

- ex) 반환값 변수명 result

> 중간점검

- 계산 로직은 모두 여러 개의 보조 함수로 빼냈기 때문에 전체 흐름을 이해하기 쉬워졌다.
- 복잡하게 얽힌 덩어리를 잘게 쪼개는 작업은 이름을 잘 짓는 일 만큼 중요하다.
- 그러나 중첩 함수가 굉장히 많다.
- 골격은 충분히 개선됐으니 이제 원하던 기능 변경의 작업이 쉬워졌다.

> 6. 계산 단계와 포맷팅 단계 분리하기

- 추가된 코드 덕분에 전체 로직을 구성하는 요소 각각이 더 뚜렷이 부각되고, 계산하는 부분과 출력 형식을 다루는 부분이 분리됐다.
- 이렇게 **모듈화하면 각 부분이 하는 일과 그 부분들이 맞물려 돌아가는 과정을 파악하기 쉬워진다.**
- 프로그래밍 만큼은 명료함이 진화할 수 있는 소프트웨어의 정수다.
