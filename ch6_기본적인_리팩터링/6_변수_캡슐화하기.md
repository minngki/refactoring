# 6.6 변수 캡슐화하기
before
```javascript
let defaultOwner = {firstName: "Martin", lastName: "Pauler"};
```
after
```javascript
let defaultOwner = {firstName: "Martin", lastName: "Pauler"};
export function defaultOwner() { return defaultOwnerData; }
export function functionsetDefaultOwner(arg) { defaultOwner = arg; }
```

## 배경
리팩터링은 결국 프로그램의 요소를 조작하는 일인데, 함수는 데이터보다 다루기가 수월하다.
- 함수로 사용한다는 건 대체로 호출한다는 뜻이고, 함수의 이름을 바꾸거나 다른 모듈로 옮기기는 어렵지 않다.
- 여차하면 기존 함수를 그대로 둔 채 전달(forward)함수로 활용할 수도 있기 때문이다.
  - 즉, 예전 코드들은 변함없이 기존 함수를 호출하고, 이 기존 함수가 새로 만든 함수를 호출하는 식이다.
- **이런 전달함수를 오래 남겨둘 일은 별로 없지만 리팩터링 작업을 간소화하는 데 큰 역할을 한다.**

반대로 데이터는 함수보다 다루기가 까다로운데, 그 이유는 이런 식으로 처리할 수 없기 때문이다. 
- 데이터는 참조하는 모든 부분을 한 번에 바꿔야 코드가 제대로 작동한다.
- 그래서 **접근할 수 있는 범위가 넓은 데이터를 옮길 때는 그 데이터로의 접근을 독점하는 함수를 만드는 식으로 캡슐화하는 것이 가장 좋은 방법**일 때가 많다.
- 데이터 재구성이라는 어려운 작업을 함수 재구성이라는 더 단순한 작업으로 변환하는 것이다.

데이터 캡슐화는 다른 경우엗 도움을 준다.
- **데이터를 변경하고 사용하는 코드를 감시할 수 있는 확실한 통로가 되어준다.**
  - 변경 전 검증이나 변경 후 로직을 쉽게 끼워 넣을 수 있다.
- **데이터의 유효범위가 넓을** 수록 캡슐화해야 한다. **레거시 코드를 다룰 때는 이런 변수를 참조하는 코드를 추가하거나 변경할 때** 마다 최대한 캡슐화한다.
  - 데이터에 대한 결합도가 높아지는 일을 막을 수 있다.

객체 지향에서 객체의 데이터를 항상 private으로 유지해야 한다고 강조하는 이유가 이 때문이다.
- public 필드를 발견할 때마다 캡슐화해서 가시 범위를 제한하는 것이 좋다.

불변 데이터는 가변 데이터보다 캡슐화할 이유가 적다. 
- 데이터가 변경될 일이 없어서 갱신 전 검증 같은 추가 로직이 자리할 공간을 마련할 필요가 없기 때문이다.
  - 불변 데이터는 옮길 필요 없이 그냥 복제하면 된다.
  - 원본 데이터를 참조하는 코드를 변경할 필요도 없고, 데이터를 변형시키는 코드를 걱정할 일도 없다.

## 절차
1. 변수로의 접근과 갱신을 전담하는 캡슐화 함수들을 만든다.
2. 정적 검사를 수행한다.
3. 변수를 직접 참조하던 부분을 모두 적절한 캡슐화 함수 호출로 바꾼다. 하나씩 바꿀 때 마다 테스트한다.
4. 변수의 접근 범위를 제한한다.
   - 변수로의 직접 접근을 막을 수 없을 때도 있다. 그럴 때는 변수 이름을 바꿔서 테스트해보면 해당 변수를 참조하는 곳을 쉽게 찾아낼 수 있다.
5. 테스트한다.
6. 변수 값이 레코드라면 레코드 캡슐화하기를 적용할지 고려해본다.